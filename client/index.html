<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Modelo test</title>

    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <!-- or include it directly from a CDN -->
    <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
    <style>
      #resultado {
        font-weight: bold;
        font-size: 6rem;
        text-align: center;
        color: red;
      }
      /* #video {
        display: none;
      } */
      .title {
        font-weight: bold;
        font-size: 2rem;
        text-align: center;
      }
      .res {
        font-weight: bold;
        font-size: 2rem;
        text-align: center;
      }
      .res {
        font-weight: bold;
        font-size: 2rem;
        text-align: center;
      }
      .frame-container {
        display: flex;
        flex-wrap: wrap;
      }
      .frame-container canvas {
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <main>
      <video id="video" playsinline autoplay width="1px"></video>
      <div class="container mt-5">
        <div class="row">
          <div class="col-12 text-center">
            <div class="row">
              <div class="col-12 col-md-6">
                <div class="text-center title">Camara</div>
                <div class="text-center">
                  PONE TUS LABIOS EN EL MEDIO DE LO VERDE
                </div>
                <canvas id="canvas" width="400" height="400"></canvas>
              </div>
              <div class="col-12 col-md-4">
                <div class="text-center title">Los realmente se manda</div>
                <canvas id="otrocanvas" width="150" height="150"></canvas>
                <div></div>
              </div>
            </div>
            <div class="row">
              <div class="col-12">
                <div>
                  Tener en cuenta de posicionar la boca dentro del rectangulo
                  verde
                </div>
                <div>
                  Para predecir hay que presionar el boton e inmediatamente o al
                  mismo tiempo decir la palabra a predecir.
                </div>

                <button class="btn btn-primary mb-2" id="start-stop">
                  Predecir
                </button>
              </div>
            </div>
            <div class="row">
              <div class="col-12">
                <div id="frame-container" class="frame-container"></div>
              </div>
            </div>
            <p id="coordinates">Coordinates: (0, 0)</p>
            <span class="res">RESULTADO:</span>
            <div id="resultado"></div>
          </div>
        </div>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script src=" https://stuk.github.io/jszip/dist/jszip.min.js"></script>
    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let canvasFrames = document.getElementById("otrocanvas");
      let ctxCanvasGeneral = canvas.getContext("2d");
      let ctxCanvasFrameToSend = canvasFrames.getContext("2d");
      const coordinates = document.getElementById("coordinates");
      const frameContainer = document.getElementById("frame-container");
      let model;
      let isRecording = false;
      let currWordFrames = [];
      let pastWordFrames = [];
      let label = "";
      let probability = 0.0;
      const synth = window.speechSynthesis
      const zip = new JSZip();

      const labelDict = {
        0: "vos",
        1: "yo",
        2: "hola",
        3: "chau",
        4: "boludo",
      };
      const TOTAL_FRAMES = 22;
      const VALID_WORD_THRESHOLD = 1;
      const PAST_BUFFER_SIZE = 4;
      const LIP_WIDTH = 112;
      const LIP_HEIGHT = 80;
      const GREEN_ZONE_LIPS_P1_Y = 202; // Define your constants appropriately
      const GREEN_ZONE_LIPS_P2_Y = 324;
      const RED_ZONE_FACE_P1_X = 115;
      const RED_ZONE_FACE_P2_X = 486;
      const RED_ZONE_FACE_P1_Y = 32;
      const RED_ZONE_FACE_P2_Y = 454;

      async function loadModel() {
        console.log("Cargando modelo...");
        class L2 {
          static className = "L2";

          constructor(config) {
            return tf.regularizers.l1l2(config);
          }
        }
        tf.serialization.registerClass(L2);
        model = await tf.loadLayersModel("./model/model.json");
        console.log("Modelo cargado");
      }
      function loadVoices(){
        return window.speechSynthesis.getVoices();
      }
      function convertToGrayscale(imageData) {
      const data = imageData;
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = avg; // Red
        data[i + 1] = avg; // Green
        data[i + 2] = avg; // Blue
      }

      return imageData;
    }

      function startVideo() {
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.play();
            processVideo();
          })
          .catch((err) => {
            console.error("Error accessing the camera", err);
          });
      }

      async function processVideo() {
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          ctxCanvasGeneral.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          // CALCULO DE RECORTE
          const rectY = (canvas.height - LIP_HEIGHT) / 2;
          const rectY_min = 30;
          const rectxCanvasGeneral_min = 20;

          // Dibujar el rectÃ¡ngulo de borde verde
          ctxCanvasGeneral.strokeStyle = "green";
          ctxCanvasGeneral.lineWidth = 5;
          ctxCanvasGeneral.strokeRect(50, rectY - 50, 300, 150);

          // En este canvas la imagen resultante deberia tener todas las trasnformaciones necesarias para enviarse, entiendase
          // BLANCO Y NEGRO
          // FILTROS BLUR.
          // SIN RECORTE.
          ctxCanvasFrameToSend.drawImage(
            video,
            0,
            0,
            canvasFrames.width,
            canvasFrames.height
          );



          // RECORTE WIDTH, HEIGHT
          let imageData = ctxCanvasFrameToSend.getImageData(
            rectxCanvasGeneral_min,
            rectY_min,
            LIP_WIDTH,
            LIP_HEIGHT
          );

          
          let lipFrame = imageData.data;
          // let lipFrame = convertToLipFrames(lipFrameOld, imageData.height, imageData.width);
          // console.log('Imprimir', lipFrame)
          if (isRecording) {
            currWordFrames.push(Array.from(convertToGrayscale(lipFrame)));
            console.log("Frames", currWordFrames.length);

            // Crear un nuevo canvas para cada frame y agregarlo al contenedor
            let frameCanvas = document.createElement("canvas");
            frameCanvas.width = imageData.width; 
            frameCanvas.height = imageData.height;
            frameContainer.appendChild(frameCanvas);
            let framectxCanvasGeneral = frameCanvas.getContext("2d");
            framectxCanvasGeneral.putImageData(imageData, 0, 0);

            if (
              Number(currWordFrames.length) + PAST_BUFFER_SIZE >=
              TOTAL_FRAMES
            ) {
              console.log("Tratando de predecir");
              await predictWord();
            }
          } else {
            pastWordFrames.push(Array.from(lipFrame));
            if (pastWordFrames.length > PAST_BUFFER_SIZE) {
              pastWordFrames.shift();
            }
          }
        }
        requestAnimationFrame(processVideo);
      }

      async function predictWord() {
        let frames = pastWordFrames.concat(currWordFrames);

        zip.file('frames.txt', JSON.stringify(frames));
        const zipFrames = await zip.generateAsync({ type: 'base64' }); // Generate base64-encoded ZIP content
        console.log("ZIPFRAMEs",zipFrames)
        // const response = await fetch('http://localhost:5000/predictions', {
        const response = await fetch('https://3vwhc9zdic.execute-api.us-east-1.amazonaws.com/predictions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: "CHINO", frames: frames })
        });

        if (response.ok) {
          // Process successful response
          const data = await response.json();
          console.log("API Response Body:", data);  // View the response body here
          label = data.prediction.label
          probability = data.prediction.probability
          // Update UI or perform other actions based on the data
        } else {
          console.error("Error sending prediction to API:", response.statusText);
        }

        let probs = null
        document.getElementById("resultado").innerText = label;
        const utterance = new SpeechSynthesisUtterance(label);
        utterance.lang = 'es-ES';
        synth.speak(utterance);
        currWordFrames = [];
        isRecording = false;
      }

      // Mostrar coordenadas del cursor en el canvas
      canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        coordinates.innerText = `Coordinates: (${x}, ${y})`;
      });
      document.getElementById("start-stop").addEventListener("click", () => {
        isRecording = !isRecording;
        frameContainer.innerHTML = "";
      });

      startVideo();
    </script>
  </body>
</html>
